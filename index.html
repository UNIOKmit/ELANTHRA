<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Volume Shader Test (WebGL2, Single File)</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#9aa; font:12px/1.4 system-ui,Segoe UI,Roboto,Arial}
  #hud{position:fixed;top:8px;left:8px;background:#0008;padding:8px 10px;border-radius:12px}
  #hud b{color:#fff}
  #hud input{vertical-align:middle}
  canvas{display:block;width:100vw;height:100vh}
  a{color:#9cf;text-decoration:none}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <div>FPS: <b id="fps">--</b></div>
  <label>Resolution scale
    <input id="scale" type="range" min="0.25" max="1" step="0.01" value="1">
    <b id="scaleVal">1.00x</b>
  </label><br/>
  <label>Max Steps <input id="steps" type="range" min="32" max="512" step="1" value="256"> <b id="stepsVal">256</b></label><br/>
  <label>Animate <input id="anim" type="checkbox" checked></label>
  <div style="margin-top:6px;opacity:.8">
    Paste your GLSL into <code>FRAG_SRC</code>. For cznull BM shader, copy from their page. 
  </div>
</div>

<script>
// ---------- Vertex Shader (full-screen triangle) ----------
const VERT_SRC = `#version 300 es
precision highp float;
const vec2 verts[3] = vec2[3]( vec2(-1.0,-1.0), vec2(3.0,-1.0), vec2(-1.0,3.0) );
out vec2 v_uv;
void main(){
  vec2 p = verts[gl_VertexID];
  v_uv = p * 0.5 + 0.5;
  gl_Position = vec4(p,0.0,1.0);
}`;

// ---------- Fragment Shader (PUT YOUR VOLUME SHADER HERE) ----------
/*
  HOW TO USE:
  1) Replace FRAG_SRC with your fragment shader.
  2) Keep the uniform names the same OR adapt main JS to your names.

  Provided uniforms:
    uniform vec2  iResolution;   // viewport pixels
    uniform float iTime;         // seconds
    uniform float iTimeDelta;    // frame dt
    uniform int   iFrame;        // frame index
    uniform int   uMaxSteps;     // UI-controlled
*/
const FRAG_SRC = `#version 300 es
precision highp float;
out vec4 FragColor;
in vec2 v_uv;

uniform vec2  iResolution;
uniform float iTime;
uniform float iTimeDelta;
uniform int   iFrame;
uniform int   uMaxSteps;

// Simple demo volume (replace with cznull shader for the "same" effect)
float sdSphere(vec3 p, float r){ return length(p)-r; }

// Signed distance field scene (example: animated blobs)
float map(vec3 p){
  float t = iTime*0.7;
  p.z += sin(t)*0.5;
  float d1 = sdSphere(p-vec3(0.7*sin(t*1.3),0.5*cos(t*1.1),0.0), 0.7);
  float d2 = sdSphere(p-vec3(-0.6*cos(t*0.9),-0.4*sin(t*1.7),0.2), 0.6);
  // smooth min
  float k = 0.35;
  float h = clamp(0.5+0.5*(d2-d1)/k, 0.0, 1.0);
  return mix(d2, d1, h) - k*h*(1.0-h);
}

// Cheap ray marcher
vec4 raymarch(vec3 ro, vec3 rd){
  float t = 0.0;
  float total = 0.0;
  for(int i=0;i<1024;i++){
    if(i>=uMaxSteps) break;
    vec3 pos = ro + rd*t;
    float d = map(pos);
    float den = clamp(0.5 - d*0.6, 0.0, 1.0); // pseudo density from SDF
    // front-to-back alpha compositing
    float a = den * 0.06;
    vec3 col = mix(vec3(0.1,0.2,0.35), vec3(0.9,0.95,1.0), den);
    FragColor.rgb += (1.0 - FragColor.a) * a * col;
    FragColor.a   += (1.0 - FragColor.a) * a;
    if(FragColor.a>0.995) break;
    t += max(0.02, d*0.5 + 0.01);
  }
  return FragColor;
}

mat3 lookAt(vec3 fwd, vec3 up){
  vec3 f = normalize(fwd);
  vec3 r = normalize(cross(up,f));
  vec3 u = cross(f,r);
  return mat3(r,u,f);
}

void main(){
  vec2 uv = (v_uv*2.0-1.0);
  uv.x *= iResolution.x / iResolution.y;

  // Camera (orbit)
  float t = iTime*0.4;
  vec3 camPos = vec3(2.6*cos(t), 1.2, 2.6*sin(t));
  vec3 target = vec3(0.0, 0.0, 0.0);
  vec3 dir = normalize(target - camPos);

  mat3 cam = lookAt(dir, vec3(0.0,1.0,0.0));
  vec3 rd = normalize(cam * normalize(vec3(uv, 1.7)));
  vec3 ro = camPos;

  FragColor = vec4(0.0);
  vec4 col = raymarch(ro, rd);

  // tone map + gamma
  vec3 mapped = col.rgb / (1.0 + col.rgb);
  mapped = pow(mapped, vec3(1.0/2.2));
  FragColor = vec4(mapped, 1.0);
}
`;

// ---------- Minimal WebGL2 setup ----------
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2', {antialias:false, preserveDrawingBuffer:false});
if(!gl){ alert('WebGL2 not supported'); throw new Error('No WebGL2'); }

function compile(type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    const info = gl.getShaderInfoLog(sh);
    console.error(info, src);
    throw new Error('Shader compile failed: '+info);
  }
  return sh;
}
function link(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.bindAttribLocation(p, 0, 'position'); // (vertexID used, but keep tidy)
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    throw new Error('Program link failed: '+gl.getProgramInfoLog(p));
  }
  return p;
}
const prog = link(compile(gl.VERTEX_SHADER, VERT_SRC), compile(gl.FRAGMENT_SHADER, FRAG_SRC));
gl.useProgram(prog);

const u_iResolution = gl.getUniformLocation(prog, 'iResolution');
const u_iTime       = gl.getUniformLocation(prog, 'iTime');
const u_iTimeDelta  = gl.getUniformLocation(prog, 'iTimeDelta');
const u_iFrame      = gl.getUniformLocation(prog, 'iFrame');
const u_uMaxSteps   = gl.getUniformLocation(prog, 'uMaxSteps');

// dummy vao for gl_VertexID
const vao = gl.createVertexArray(); gl.bindVertexArray(vao);

// UI wiring
const scaleEl = document.getElementById('scale');
const stepsEl = document.getElementById('steps');
const animEl  = document.getElementById('anim');
const fpsEl   = document.getElementById('fps');
const scaleVal= document.getElementById('scaleVal');
const stepsVal= document.getElementById('stepsVal');

let width=0, height=0, scale=+scaleEl.value;
function resize(){
  scale = +scaleEl.value;
  scaleVal.textContent = scale.toFixed(2)+'x';
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const w = Math.max(1, Math.floor(innerWidth  * dpr * scale));
  const h = Math.max(1, Math.floor(innerHeight * dpr * scale));
  if(w===width && h===height) return;
  width=w; height=h;
  canvas.width = w; canvas.height = h;
  canvas.style.width  = innerWidth+'px';
  canvas.style.height = innerHeight+'px';
  gl.viewport(0,0,w,h);
}
addEventListener('resize', resize, {passive:true});
scaleEl.addEventListener('input', resize);

stepsEl.addEventListener('input', ()=>{ stepsVal.textContent = stepsEl.value; });

let t0=performance.now(), tPrev=t0, frame=0, acc=0, fps=0;
function tick(now){
  resize();

  const animate = animEl.checked;
  const dt = (now - tPrev)/1000; tPrev = now;
  if(dt<1) { acc += 1; if(now - t0 >= 1000){ fps = acc; acc = 0; t0 = now; fpsEl.textContent = fps|0; } }

  gl.useProgram(prog);
  gl.uniform2f(u_iResolution, width, height);
  gl.uniform1f(u_iTime, animate ? now/1000 : 0.0);
  gl.uniform1f(u_iTimeDelta, dt);
  gl.uniform1i(u_iFrame, frame++);
  gl.uniform1i(u_uMaxSteps, parseInt(stepsEl.value,10));

  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(tick);
}
resize(); stepsVal.textContent = stepsEl.value;
requestAnimationFrame(tick);
</script>
</body>
</html>
